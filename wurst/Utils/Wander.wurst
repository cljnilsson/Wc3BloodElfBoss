package Wander

import ClosureTimers
import pathable

public group wanderers = CreateGroup()
hashtable hash = InitHashtable()
trigger onPause = CreateTrigger()
trigger onResume = CreateTrigger()

real offset = 1000
real delay = 2

unit wanderer

public function getWanderingUnit() returns unit
    return wanderer

public function unit.startWander()
    hash.saveReal(this.getHandleId(), 2, this.getX())
    hash.saveReal(this.getHandleId(), 3, this.getY())
    hash.saveBoolean(this.getHandleId(), 6, true)
    this.generateWanderVec()
    wanderers.addUnit(this)

public function unit.isWandering() returns boolean
    return wanderers.contains(this)


public function unit.hasWandered() returns boolean
    return hash.loadBoolean(this.getHandleId(), 6)

public function unit.pauseWandering()
    wanderers.removeUnit(this)

public function unit.resumeWandering()
    this.generateWanderVec()
    wanderers.addUnit(this)

function vec2.polarProjection(real dist, real angle) returns vec2
    real x = this.x + dist * Cos(angle * bj_DEGTORAD)
    real y = this.y + dist * Sin(angle * bj_DEGTORAD)
    return vec2(x, y)

public function unit.attachWanderToUnit(unit u)
    hash.saveUnitHandle(this.getHandleId(), 7, u)

public function unit.isAttached() returns boolean
    return hash.loadUnitHandle(this.getHandleId(), 7) != null

public function wanderOnPause(code c)
    onPause.addAction(c)


public function wanderOnResume(code c)
    onResume.addAction(c)

function unit.generateWanderVec() returns vec2
    int id = this.getHandleId()
    vec2 pos = this.isAttached() ? vec2(hash.loadUnitHandle(id, 7).getX(), hash.loadUnitHandle(id, 7).getY()) : vec2(hash.loadReal(id, 2), hash.loadReal(id, 3))

    vec2 randomPos = pos.polarProjection(GetRandomReal(50, offset), GetRandomReal(1, 360))

    while randomPos.isTerrainWalkable() == false
        randomPos = pos.polarProjection(GetRandomReal(50, offset), GetRandomReal(1, 360))

    hash.saveReal(id, 0, randomPos.x)
    hash.saveReal(id, 1, randomPos.y)

    this.issuePointOrder("move", randomPos)

    return randomPos

init    
    doPeriodically(0.03) cb ->
        for u in wanderers
            /*if OrderId2String(u.getCurrentOrder()) == null
                u.generateWanderVec()*/
            integer id = u.getHandleId()
            vec2 goal = vec2(hash.loadReal(id, 0), hash.loadReal(id, 1))
            vec2 pos = u.getPos()
            if pos.distanceTo(goal) < 100
                u.pauseWandering()
                wanderer = u
                onPause.execute()
                doAfter(delay) ->
                    u.resumeWandering()
                    wanderer = u
                    onResume.execute()